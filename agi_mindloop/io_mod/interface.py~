from __future__ import annotations
from pathlib import Path
from typing import Optional
import tkinter as tk
from tkinter import ttk, filedialog, scrolledtext


class Interface:
    """Interactive interface backed by a Tkinter chat-style window
    with selectable LLM models for each role.
    """
    

    def __init__(self) -> None:
        self._headless = False
        self._closed = False
        self._pending_value: Optional[str] = None
        self._root = None
        self._chat = None
        self._entry_var = None
        self._input_var = None
        self._filedialog = None

        try:
                      
# --- Create root window first ---
            self._root = tk.Tk()
            self._root.title("AGI MindLoop Chat")
            self._root.geometry("880x680")
            self._root.minsize(700, 600)
            # --- Global font scaling ---
            self._root.option_add("*Font", "TkDefaultFont 20 bold")
            self._root.option_add("*TButton.Font", "TkDefaultFont 20 bold")
            self._root.option_add("*TLabel.Font", "TkDefaultFont 20 bold")

            # --- Now that a root exists, create model selection variables ---
            self.model_selections = {
                "neutral_a": tk.StringVar(master=self._root, value="openai:gpt-4.1"),
                "mooded_b": tk.StringVar(master=self._root, value="openai:gpt-4.1"),
                "summarizer": tk.StringVar(master=self._root, value="openai:gpt-4.1"),
                "coder": tk.StringVar(master=self._root, value="openai:gpt-4.1"),
            }

            # --- Dropdowns for model selection ---
            model_frame = ttk.LabelFrame(self._root, text="Select Models")
            model_frame.pack(fill="x", padx=10, pady=6)

            models = [
                "openai:gpt-4.1",
                "openai:gpt-4-turbo",
                "openai:gpt-o4-mini",
                "gpt4all:reasonerv1",
                "gpt4all:Llama 3.2 3B Instruct",
                "gpt4all:Llama 3.1 8B Instruct 128k",
                "ollama:llama3",
                "stub",
            ]

            for key, var in self.model_selections.items():
                ttk.Label(model_frame, text=f"{key}:").pack(side="left", padx=(5, 0))
                menu = ttk.OptionMenu(model_frame, var, var.get(), *models)
                menu.pack(side="left", padx=(0, 10))

            # --- Chat window ---
            self._chat = scrolledtext.ScrolledText(
                self._root, state="disabled", wrap="word", padx=12, pady=12
            )
            self._chat.pack(fill="both", expand=True)
            self._chat.configure(font=("TkDefaultFont", 20))

            # --- Input field ---
            self._entry_var = tk.StringVar()
            input_frame = tk.Frame(self._root)
            input_frame.pack(fill="x", padx=10, pady=(0, 10))

            attach_btn = tk.Button(
                input_frame,
                text="+",
                width=2,
                command=self._on_attach,
                font=("TkDefaultFont", 20, "bold"),
            )
            attach_btn.grid(row=0, column=0, padx=(0, 8))

            entry = tk.Entry(input_frame, textvariable=self._entry_var, font=("TkDefaultFont", 18))
            entry.pack(side="left", fill="x", expand=True)
            entry.bind("<Return>", self._on_send_event)

            send_btn = tk.Button(input_frame, text="Send", command=self._on_send)
            send_btn.pack(side="left", padx=5)

            # --- Context menu ---
            self._menu = tk.Menu(self._root, tearoff=0)
            self._menu.add_command(label="Cut", command=lambda: self._chat.event_generate("<<Cut>>"))
            self._menu.add_command(label="Copy", command=lambda: self._chat.event_generate("<<Copy>>"))
            self._menu.add_command(label="Paste", command=lambda: self._chat.event_generate("<<Paste>>"))
            self._chat.bind("<Button-3>", self._show_context_menu)

            self._input_var = tk.StringVar(value="")
            self._filedialog = filedialog
            self._root.protocol("WM_DELETE_WINDOW", self._on_close)

            self._append_message("System", "Welcome to AGI MindLoop!", "system")
            entry.focus_set()

        except Exception as e:
               import traceback
               print("Interface init failed:", e)
               traceback.print_exc()
               self._headless = True 

    # ------------------------------------------------------------------
    # Public API
    # ------------------------------------------------------------------
    def get_input(self) -> str:
        if self._headless:
            return "demo input"
        if self._closed:
            raise RuntimeError("Interface window has been closed by the user.")
        assert self._input_var is not None

        self._input_var.set("")
        self._pending_value = None
        self._root.deiconify()
        self._root.lift()
        self._root.after(0, lambda: self._root.focus_force())
        self._root.wait_variable(self._input_var)

        if self._closed:
            raise RuntimeError("Interface window has been closed by the user.")

        value = self._pending_value or ""
        self._pending_value = None
        return value

    def send_output(self, text: str) -> None:
        label, message, label_overridden = self._extract_label_and_message(text)

        if self._headless or self._closed:
            if not label_overridden:
                print(text)
            else:
                print(f"{label}: {message}")
            return

        # Color settings for MindLoop output
        label_font = ("TkDefaultFont", 20, "bold")
        self._chat.tag_configure("assistant_label", foreground="#38761d", font=label_font)
        self._chat.tag_configure("assistant_text", foreground="#1E90FF")  # DodgerBlue

        self._append_message(label, message, "assistant")

    # ------------------------------------------------------------------
    # Internal helpers
    # ------------------------------------------------------------------
    def _extract_label_and_message(self, text: str) -> tuple[str, str, bool]:
        """Extract optional 'Label: message' format for chat display."""
        default_label = "MindLoop"
        if not text:
            return default_label, "", False

        first_line, *rest = text.splitlines()
        label = default_label

        colon_index = first_line.find(":")
        if colon_index != -1:
            prefix = first_line[:colon_index].strip()
            suffix = first_line[colon_index + 1:].lstrip()
            if prefix and self._is_label_candidate(prefix):
                label = prefix
                body_lines: list[str] = []
                if suffix:
                    body_lines.append(suffix)
                if rest:
                    body_lines.extend(rest)
                message = "\n".join(body_lines).strip()
                return label, message, True

        return label, text.strip(), False

    @staticmethod
    def _is_label_candidate(text: str) -> bool:
        """Check if the prefix looks like a valid speaker label."""
        if not text:
            return False
        for char in text:
            if not (char.isalpha() or char.isspace() or char in {"-", "_"}):
                return False
        return True

    def _append_message(self, speaker: str, message: str, role: str) -> None:
        if self._headless or self._chat is None:
            return

        self._chat.configure(state="normal")
        label_tag = f"{role}_label"
        text_tag = f"{role}_text"
        self._chat.insert("end", f"{speaker}: ", label_tag)
        self._chat.insert("end", f"{message}\n", text_tag)

        # Keep only the last two complete message blocks (user + MindLoop)
        text = self._chat.get("1.0", "end-1c")
        blocks = text.strip().split("\n")
        if len(blocks) > 12:  # roughly allows two full exchanges
            self._chat.delete("1.0", f"{len(blocks) - 12}.0")

        self._chat.configure(state="disabled")
        self._chat.see("end")
        if self._root is not None:
            self._root.update_idletasks()

    def _show_context_menu(self, event):
        try:
            self._menu.tk_popup(event.x_root, event.y_root)
        finally:
            self._menu.grab_release()

    def _on_send_event(self, event) -> None:
        self._on_send()
        return "break"

    def _on_send(self) -> None:
        if self._headless or self._closed:
            return

        assert self._entry_var is not None
        text = self._entry_var.get().strip()
        if not text:
            return

        self._entry_var.set("")
        self._submit_text(text)

    def _on_attach(self) -> None:
        if self._headless or self._closed or self._filedialog is None:
            return

        filename = self._filedialog.askopenfilename(title="Select a file to import")
        if not filename:
            return

        path = Path(filename)
        try:
            data = path.read_bytes()
        except Exception as exc:
            self._append_message(
                "System", f"Failed to import '{path.name}': {exc}", "system"
            )
            return

        content = data.decode("utf-8", errors="replace")
        char_limit = 4000
        truncated = len(content) > char_limit
        display_content = content[:char_limit]
        message = f"[Imported file: {path.name}]\n{display_content}"
        if truncated:
            message += "\n...[truncated]..."

        assert self._entry_var is not None
        existing_text = self._entry_var.get().strip()
        if existing_text:
            combined = f"{existing_text}\n\n{message}"
        else:
            combined = message

        self._entry_var.set("")
        self._submit_text(combined)

    def _on_close(self) -> None:
        if self._closed or self._headless:
            return
        self._closed = True
        if self._input_var is not None:
            self._input_var.set("__CLOSED__")
        if self._root is not None:
            self._root.destroy()
            self._root = None
        self._chat = None

    def _submit_text(self, text: str) -> None:
        if self._headless or self._closed:
            return
        text = text.strip()
        if not text:
            return
        self._append_message("You", text, "user")
        self._pending_value = text
        self._input_var.set(text)

